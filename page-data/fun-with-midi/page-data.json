{"componentChunkName":"component---src-templates-blog-post-js","path":"/fun-with-midi/","result":{"data":{"site":{"siteMetadata":{"title":"Tech Blog"}},"markdownRemark":{"id":"b4415f31-115b-5ba1-a97e-c2f667fb949b","excerpt":"This was originally written for a zine. Code, schematics, etc can be found on Github. Hey üëã My name is Matthew and I don‚Äôt understand analog circuits. Boy have‚Ä¶","html":"<p>This was originally written for a zine. Code, schematics, etc can be <a href=\"https://github.com/handeyeco/fun-with-midi\">found on Github</a>.</p>\n<hr>\n<p>Hey üëã My name is Matthew and I don‚Äôt understand analog circuits.</p>\n<p>Boy have I tried though. Just looking around my desk I can see my copy of There Are No Electrons by Amdahl, Practical Electronics For Inventors by Scherz, and Electronic Projects For Musicians by Anderton. My degree is in Music Business, Performance, and Technology and I‚Äôve worked TWO jobs assembling modular synthesizers - one before and one after my career as an audio engineer, before I made the switch to software development.</p>\n<p>Circuits are hard. I discovered something though - on my 100th attempt at learning electrical engineering - that there‚Äôs buckets of fun to be had with a relatively simple circuit and some basic programming skills.</p>\n<p>In this article I‚Äôm going to talk a little about MIDI.</p>\n<h2>WARNING</h2>\n<p>Your hearing is fragile, be sure to protect it when programmatically adjusting audio. I recommend getting some cheap, small speakers from a thrift store to use while debugging. Always start each iteration with your volume turned down and carefully turn the volume up when you‚Äôre confident your project is working.</p>\n<p>You can always fix bugs, but you can‚Äôt fix tinnitus!</p>\n<h2>What we‚Äôre doing</h2>\n<p>We‚Äôre going to use an Arduino and a simple MIDI out circuit for three sketches:</p>\n<ol>\n<li>To get things started, we‚Äôll run a sketch that makes sure all the buttons, potentiometers, and LEDs are working.</li>\n<li>Then we‚Äôll test our MIDI out circuit by making a vanilla MIDI CC controller that lets us pick a MIDI CC and a value for that CC.</li>\n<li>Finally we‚Äôll look at a more creative application of MIDI by making a random MIDI CC generator that can be used to turn boring synth patches into modular-like bleeps and bloops.</li>\n</ol>\n<p>Each sketch will build on the previous sketch so hopefully by the end you can take these ideas and build your own weird MIDI tool!</p>\n<h2>What I‚Äôm using</h2>\n<p>For these examples I‚Äôm using an Arduino Mega ($50; an Uno should work fine though) and the Sparkfun MIDI Shield ($24). Arduino is designed to be a beginner-friendly platform for people who are learning about microcontrollers. Shields are just circuits that are meant to extend the functionality of another circuit.</p>\n<p>If you want to follow along and have the cash, I highly recommend throwing some dough at both Arduino and Sparkfun - they contribute a lot to the DIY scene. However you can get equally far with a $10 Arduino knock-off and some common components.</p>\n<h2>The circuit</h2>\n<p>Even though MIDI in makes everything more fun, for the sake of simplicity I‚Äôm just using MIDI out, two potentiometers, three buttons, and two LEDs. You can see the Sparkfun MIDI Shield schematic on their site, but the parts I‚Äôm using for these examples are:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/tech-blog/static/7e995fa6d909c88a421c98c0552175cf/b85c3/simplified-schematic.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.1891891891892%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACT0lEQVQ4y31T227TQBTM//8OpaKolQgIVeKtSA1KaRLXsddee2/ei21oyzB2mpK+8HC0sXM8Zy5nFyk5/K/63sF5DR8Mhr5DZIXp/WuPnU/b6flc9Gw4rTeAfcAwJoLZuSLfaV2hFg8YBj/3t10FaySca+bnxTQhntSRVeIH0eaw4hZNfoOuvUeIFo6AqtjC9waJrFvJnk5BZnfQPBdaCdRNBqn2rByGz4Fs+uDhqiWHXMCGj/zwCkFLDL8i4uigjECzXkHdrdBm99BNQWsMFpb+2FbAqppg1TyxdgJSZNiszhCfPuEJXyCqS9iqRD/6g4rUoZMEofzoFK2JB8mT0TbIuVpf0hNWJKDMkK/f4xmf8chq6ksyFhjJcCDY5KdyLfK6gCapY0iLaVKgd3727+BhGtjMxmJ9TsAl/pChbS6hxA62VxzewIUWykt00czezr4fU/aM3JH2NN1HJknDRblFRslPBAS+otidQdyv4UaNhio8QbrYEljN8lM6BYwKjc7RFhml5XjY3KLcb3F3845yl0jPS2y3Z1C7DOPvBEOGHRONHKydRD8z7E4Ak4HpJJQsYW3Dmn4LhnLwMBJwv/8As8/RPyZo+ltv1/S8RbNZoWao6RXwxUNtGUT5wJQLlJsfMJ5S9DXX4xzCXEDXV3A1QyGgJ4DcUT6ZaQI33I5XhodFJiiTkiJHpJSg63lidBXKn99QZN+hpx3lf47LPH1jqGLk8hsmHRnMG8Aj6DCGwxUcXnZtCJDTtWJQxtv5JnQEnFZmAp56pzPGf3f7L26X1Abi2SjOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Schematic of MIDI out circuit with simple controls\"\n        title=\"Schematic of MIDI out circuit with simple controls\"\n        src=\"/tech-blog/static/7e995fa6d909c88a421c98c0552175cf/fcda8/simplified-schematic.png\"\n        srcset=\"/tech-blog/static/7e995fa6d909c88a421c98c0552175cf/12f09/simplified-schematic.png 148w,\n/tech-blog/static/7e995fa6d909c88a421c98c0552175cf/e4a3f/simplified-schematic.png 295w,\n/tech-blog/static/7e995fa6d909c88a421c98c0552175cf/fcda8/simplified-schematic.png 590w,\n/tech-blog/static/7e995fa6d909c88a421c98c0552175cf/efc66/simplified-schematic.png 885w,\n/tech-blog/static/7e995fa6d909c88a421c98c0552175cf/c83ae/simplified-schematic.png 1180w,\n/tech-blog/static/7e995fa6d909c88a421c98c0552175cf/b85c3/simplified-schematic.png 2580w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>MIDI out, which is just a 5 pin DIN socket with two resistors</li>\n<li>Two potentiometers acting as voltage dividers going into analog pins on the Arduino</li>\n<li>Three switches going into digital pins on the Arduino (we‚Äôll be using the internal pull-up resistors)</li>\n<li>Two LEDs with current limiting resistors</li>\n</ul>\n<p>If you‚Äôve been playing with electronics already, there‚Äôs a good chance you have most of this stuff lying around except maybe the Arduino and the DIN socket (using a 3.5mm jack for TRS MIDI is also an option).</p>\n<h2>Sketch #1: Board Test</h2>\n<p>Source: <a href=\"https://github.com/handeyeco/fun-with-midi/blob/main/board-test/board-test.ino\">https://github.com/handeyeco/fun-with-midi/blob/main/board-test/board-test.ino</a></p>\n<p>This first sketch is just testing the pots, buttons, and LEDs. First we let the program know which pins we‚Äôre using for everything:</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">// button pins (digital)\nbyte S3_PIN = 4;\nbyte S4_PIN = 3;\nbyte S5_PIN = 2;\n\n// pot pins (analog)\nbyte RV1_PIN = A1;\nbyte RV2_PIN = A0;\n\n// LED pins (digital)\nbyte GRN_LED_PIN = 6;\nbyte RED_LED_PIN = 7;</code></pre></div>\n<p>Then we declare some variables so we can keep track of what everything is doing as the sketch runs:</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">// declare read state\nbool S3_STATE = 1;\nbool S4_STATE = 1;\nbool S5_STATE = 1;\nint RV1_STATE = 0;\nint RV2_STATE = 0;</code></pre></div>\n<p><code class=\"language-text\">setup</code> is the code that runs at the beginning of the sketch:</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">void setup() {\n  // setup for printing to our monitor\n  Serial.begin(9600);\n\n  // the switches use the built-in pull-up resistors\n  pinMode(S3_PIN, INPUT_PULLUP);\n  pinMode(S4_PIN, INPUT_PULLUP);\n  pinMode(S5_PIN, INPUT_PULLUP);\n\n  // the pots don&#39;t use the pull-up resistors\n  pinMode(RV1_PIN, INPUT);\n  pinMode(RV2_PIN, INPUT);\n\n  // then set up the LEDs as outputs\n  pinMode(GRN_LED_PIN, OUTPUT);\n  pinMode(RED_LED_PIN, OUTPUT);\n\n  // do an initial read of everything\n  // so we can start looking for changes\n  S3_STATE = digitalRead(S3_PIN);\n  S4_STATE = digitalRead(S4_PIN);\n  S5_STATE = digitalRead(S5_PIN);\n  RV1_STATE = analogRead(RV1_PIN);\n  RV2_STATE = analogRead(RV2_PIN);\n}</code></pre></div>\n<p><code class=\"language-text\">loop</code> runs over and over again so we can watch for changes:</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">// pot change threshold,\n// for what we consider a change\nint RV_THRESH = 3;\n\nvoid loop() {\n  // read pins\n  bool S3_READ = digitalRead(S3_PIN);\n  bool S4_READ = digitalRead(S4_PIN);\n  bool S5_READ = digitalRead(S5_PIN);\n  int RV1_READ = analogRead(RV1_PIN);\n  int RV2_READ = analogRead(RV2_PIN);\n\n  // if any button is pressed, light LED\n  bool pressed = S3_READ &amp;&amp; S4_READ &amp;&amp; S5_READ;\n  digitalWrite(GRN_LED_PIN, pressed);\n  digitalWrite(RED_LED_PIN, pressed);\n\n  // print and update state\n  // if a change is detected\n  if (S3_READ != S3_STATE) {\n    Serial.println(&quot;S3&quot;);\n    S3_STATE = S3_READ;\n  }\n  if (S4_READ != S4_STATE) {\n    Serial.println(&quot;S4&quot;);\n    S4_STATE = S4_READ;\n  }\n  if (S5_READ != S5_STATE) {\n    Serial.println(&quot;S5&quot;);\n    S5_STATE = S5_READ;\n  }\n  if (abs(RV1_READ - RV1_STATE) &gt; RV_THRESH) {\n    Serial.println(&quot;RV1&quot;);\n    RV1_STATE = RV1_READ;\n  }\n  if (abs(RV2_READ - RV2_STATE) &gt; RV_THRESH) {\n    Serial.println(&quot;RV2&quot;);\n    RV2_STATE = RV2_READ;\n  }\n}</code></pre></div>\n<p>What it‚Äôs doing:</p>\n<ol>\n<li>If any buttons are pressed, light up the LEDs</li>\n<li>If any button is pressed, print in the serial monitor which button was pressed</li>\n<li>If any pot is turned, print in the serial monitor which pot was turned</li>\n</ol>\n<p>Okay, not super fun so far, but hopefully we have a working Arduino connected to a working MIDI shield. Now let‚Äôs actually <em>do</em> something with the MIDI output.</p>\n<h2>Serial, USB, and MIDI</h2>\n<p>Okay, here‚Äôs some bummer news: the <code class=\"language-text\">Serial</code> protocol we used to print messages in the previous example doesn‚Äôt play well with hardware MIDI. The problem is that both USB communication and hardware MIDI rely on UART (connected to the TX/RX pins). This is why the MIDI shield has a prog/run switch: when we‚Äôre sending our sketch to the Arduino, we can‚Äôt also be receiving MIDI or our bits will get all mixed up. The switch turns off MIDI in while we program the microcontroller.</p>\n<p>This isn‚Äôt a huge issue for now since we‚Äôre only using MIDI out, but it‚Äôs something to keep in mind. It does however limit our ability to use <code class=\"language-text\">Serial.print</code> while also using MIDI.</p>\n<p>The good news is that some Arduinos have multiple UARTs; for example the Mega has 4 sets of UART pins. This means you can use one set for programming/debugging and one set for MIDI. Unfortunately the MIDI shield is designed to work with the Uno too, which only has one set, so the issues exists with the shield on the Mega.</p>\n<p>So:</p>\n<ol>\n<li>We won‚Äôt use <code class=\"language-text\">Serial.print</code> while also using MIDI</li>\n<li>If we have something plugged into MIDI in, we‚Äôll use the prog/run switch to disconnect it while programming our Arduino</li>\n<li>If in the future we design our own circuits, we‚Äôll use a microcontroller with multiple UARTS so MIDI can be on its own</li>\n</ol>\n<h2>Sketch #2: MIDI CC Controller</h2>\n<p>Source: <a href=\"https://github.com/handeyeco/fun-with-midi/blob/main/cc-controller/cc-controller.ino\">https://github.com/handeyeco/fun-with-midi/blob/main/cc-controller/cc-controller.ino</a></p>\n<p>I‚Äôm not going to explain MIDI or MIDI CC in a lot of detail. You have access to the internet. I‚Äôm just going to say that MIDI is how digital music devices communicate with one another and MIDI CC is how we control parameters on one device from another device.</p>\n<p>This script will give us the power to change parameters on a remote device from our Arduino. Imagine being able to change the filter cutoff on your synth from the other side of the room - that <em>can</em> be a reality for you!</p>\n<p>The code is much more concise as it takes the last example and cuts a lot away from it. We‚Äôre only going to use the pots here:</p>\n<ul>\n<li>One pot will control which CC we‚Äôre modifying. For instance on the Hydrasynth, filter 1 cutoff is MIDI CC 74 and LFO 1 rate is MIDI CC 72. Your synth‚Äôs manual should tell you what CC controls what parameter.</li>\n<li>The other pot will control the value of the MIDI CC. Most of MIDI works with 7 bits which gives us a range between 0 and 127 (128 steps).</li>\n</ul>\n<p>First we import FortySevenEffects‚Äô MIDI library (<a href=\"https://github.com/FortySevenEffects/arduino_midi_library\">https://github.com/FortySevenEffects/arduino_midi_library</a>) and initialize it:</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;MIDI.h&gt;\n\nMIDI_CREATE_DEFAULT_INSTANCE();</code></pre></div>\n<p>We set pins and initalize state like before; this time though we also have to start the MIDI library. Additionally I‚Äôve added a helper function to map 0-1023 (the full range that an Arduino‚Äôs <code class=\"language-text\">analogRead</code> can supply) to 0-127 (the full range that MIDI can use).</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">// pot pins\nbyte RV1_PIN = A1;\nbyte RV2_PIN = A0;\n\n// declare read state\nint RV1_STATE = 0;\nint RV2_STATE = 0;\n\nint read_and_map(byte pin) {\n  int read = analogRead(pin);\n  return map(read, 0, 1023, 0, 127);\n}\n\nvoid setup() {\n  MIDI.begin(MIDI_CHANNEL_OMNI);\n\n  // set pin modes\n  pinMode(RV1_PIN, INPUT);\n  pinMode(RV2_PIN, INPUT);\n\n  // initialize read state\n  RV1_STATE = read_and_map(RV1_PIN);\n  RV2_STATE = read_and_map(RV2_PIN);\n}</code></pre></div>\n<p>Now the juicy bit:</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">// there are 16 MIDI channels,\n// I just used the first one\nbyte MIDI_CH = 1;\n\nvoid loop() {\n  // read pins\n  int RV1_READ = read_and_map(RV1_PIN);\n  int RV2_READ = read_and_map(RV2_PIN);\n\n  // RV1 adjusts which CC channel we&#39;re changing\n  if (RV1_READ != RV1_STATE) {\n    RV1_STATE = RV1_READ;\n  }\n  // RV2 adjusts the CC value\n  if (RV2_READ != RV2_STATE) {\n    RV2_STATE = RV2_READ;\n    // sendControlChange(CC, value, channel)\n    MIDI.sendControlChange(RV1_STATE, RV2_STATE, MIDI_CH);\n  }\n}</code></pre></div>\n<p>What this sketch does:</p>\n<ul>\n<li>It watches for changes on the RV1 potentiometer and if it changes we change the MIDI CC we‚Äôre going to adjust</li>\n<li>It watches for changes on the RV2 potentiometer and if it changes we send a MIDI CC message to our MIDI output using the MIDI CC from RV1 and the value from RV2</li>\n</ul>\n<p>In theory we could use RV1 to go to MIDI CC 74 then use RV2 to adjust the filter cutoff on our Hydrasynth. Or use RV1 to go to MIDI CC 81 then use RV2 to adjust envelope 1 attack.</p>\n<p>In practice this is a little tough because we don‚Äôt have a display to tell us what MIDI CC we‚Äôre on. For now we could use an app like MIDI Monitor to see our work in action and later we could add a cheap I2C OLED screen to tell us what‚Äôs happening.</p>\n<h2>Sketch #3: Random CC</h2>\n<p>Source: <a href=\"https://github.com/handeyeco/fun-with-midi/blob/main/random-cc/random-cc.ino\">https://github.com/handeyeco/fun-with-midi/blob/main/random-cc/random-cc.ino</a></p>\n<p>Let‚Äôs go one step further and make something that‚Äôs actually fun to use without adding a screen or connecting it to a computer. Modular folks think they have all the fun with their bleeps and their bloops and their endless modulation options, but now that we know we can control synths using MIDI CC, we can make our own obnoxious sounds!</p>\n<p>Here‚Äôs what this sketch is going to do:</p>\n<ul>\n<li>We‚Äôre going to pick a MIDI CC and start sending it random values.</li>\n<li>RV2 will determine how often we send a random value: really fast or really slow.</li>\n<li>\n<p>RV1 will do different things based on the buttons:</p>\n<ul>\n<li>When we press S3 we‚Äôll turn off all the LEDs and RV1 will change the offset of the MIDI CC. MIDI CC works between 0 and 127; offset will set the lowest possible value our random CC generator will send.</li>\n<li>When we press S4 we‚Äôll turn on the green LED and RV1 will now change the depth of the MIDI CC. This essentially will set the highest possible value our random CC generator will send.</li>\n<li>When we press S5 we‚Äôll turn on the red LED and RV1 will now change the MIDI CC that we‚Äôre sending to. Basically chosing what parameter we want to control.</li>\n</ul>\n</li>\n</ul>\n<p>So when ‚Äúoffset‚Äù is 0 and ‚Äúdepth‚Äù is 127, we‚Äôll get random CCs between 0 and 127. When ‚Äúoffset‚Äù is 64 and ‚Äúdepth‚Äù is 127, we‚Äôll get random CCs between 64 and 127 (we‚Äôll clamp the maximum output to 127 since that‚Äôs the max MIDI CC can handle). When ‚Äúoffset‚Äù is 64 and ‚Äúdepth‚Äù is 10, we‚Äôll get random CCs between 64 and 74.</p>\n<p>So by default we‚Äôll generate random CCs using the full CC range:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/tech-blog/static/06abf80ea7eb47c0ac6039f63969c6d3/26162/wide-scatter.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA/0lEQVQoz51SQRKEIAzj/6/1oKOWFJZAi5Xd0zoTxdKGNDRd11W3bevY973yKaX8jcQXSQFUVe1BaANGghJq6/bN0Ll2krnfCYemFqidiJsaTkQneavQ8s5Ry5sK7/vu6hAUEFxf8iiCdSAt7mpdHawuUR/JqCK28aUoKNcAV1bdQ/pHhbFYjHw9gMWSh7/Qt393HmrTeZ71bKROACMTK9JgfDyAee4twt5seV6IE4dWshXHS3MbfN/XaZyObjgsuJK6Io/NkdKHzJE4MrnN4HoRY5QeX/kfEX3VkP/cckYfbpIjYMbbV/J3PNaQJ412mJBfRCuO46gi8pPQ/0n4AfqmtpnPAT66AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Scatter plot of a wide CC range\"\n        title=\"Scatter plot of a wide CC range\"\n        src=\"/tech-blog/static/06abf80ea7eb47c0ac6039f63969c6d3/fcda8/wide-scatter.png\"\n        srcset=\"/tech-blog/static/06abf80ea7eb47c0ac6039f63969c6d3/12f09/wide-scatter.png 148w,\n/tech-blog/static/06abf80ea7eb47c0ac6039f63969c6d3/e4a3f/wide-scatter.png 295w,\n/tech-blog/static/06abf80ea7eb47c0ac6039f63969c6d3/fcda8/wide-scatter.png 590w,\n/tech-blog/static/06abf80ea7eb47c0ac6039f63969c6d3/efc66/wide-scatter.png 885w,\n/tech-blog/static/06abf80ea7eb47c0ac6039f63969c6d3/c83ae/wide-scatter.png 1180w,\n/tech-blog/static/06abf80ea7eb47c0ac6039f63969c6d3/26162/wide-scatter.png 2020w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>But we can narrow that range using offset and depth:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/tech-blog/static/15d52dbcd90e019fd64995ecc836fe69/26162/narrow-scatter.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsElEQVQoz61SSRLDIAzL/19LLmHzUmQDTXtgOiXMCOMlQiY+UkoaQtDzPM0ys4rI3ziwgZSIjGybUNsyR33tkE2FOWeVTWUfCtEmUWu9iNZmiaXF3JbqZwC50mF1DSxv3wjxflA4yHJ14lS4w0lxzjdbbnUjj++PGKPGmKYK+gJiUxG7Ist1f8RHbrb8xPvNn+Ij8zAh7Gpsfh2p2XKt1Yh3AJ7b2KwLr+uyS1e1yL0AmXe2jS+bmAwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Scatter plot of a narrow CC range\"\n        title=\"Scatter plot of a narrow CC range\"\n        src=\"/tech-blog/static/15d52dbcd90e019fd64995ecc836fe69/fcda8/narrow-scatter.png\"\n        srcset=\"/tech-blog/static/15d52dbcd90e019fd64995ecc836fe69/12f09/narrow-scatter.png 148w,\n/tech-blog/static/15d52dbcd90e019fd64995ecc836fe69/e4a3f/narrow-scatter.png 295w,\n/tech-blog/static/15d52dbcd90e019fd64995ecc836fe69/fcda8/narrow-scatter.png 590w,\n/tech-blog/static/15d52dbcd90e019fd64995ecc836fe69/efc66/narrow-scatter.png 885w,\n/tech-blog/static/15d52dbcd90e019fd64995ecc836fe69/c83ae/narrow-scatter.png 1180w,\n/tech-blog/static/15d52dbcd90e019fd64995ecc836fe69/26162/narrow-scatter.png 2020w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>This code shares a lot from the first two examples, so I‚Äôm just going to talk about the important changes. First we initialize some state:</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">// what editing mode we&#39;re in:\n// 0 = offset (no LEDs)\n// 1 = depth (green LED)\n// 2 = CC (red LED)\nbyte RV1_edit_mode = 0;\n\n// offset is our lowest possible CC\nint offset = 0;\n// depth is how far from\n// the lowest CC we can go\nint depth = 127;\n// the MIDI CC we&#39;re sending values for\n// 74 is commonly the CC for filter cutoff\nbyte cc = 74;\n\n// these are used to set our\n// MIDI message interval\nint MIN_SPEED = 60;\nint MAX_SPEED = 1000;\nint speed = MAX_SPEED;\nunsigned long last_cc_sent = 0;</code></pre></div>\n<p>Next we check each button to see if they have been pressed and if we detect a change we update the mode we‚Äôre in, for example:</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">  byte old_RV1_edit_mode = RV1_edit_mode;\n\n  // update edit state if button change detected\n  if (S3_READ != S3_STATE) {\n    S3_STATE = S3_READ;\n    // set RV1_edit_mode to offset\n    if (S3_STATE == LOW) {\n      RV1_edit_mode = 0;\n    }\n  }\n\n  // ...similar for the other buttons...\n\n  // watch for changes to edit mode and update LEDs\n  if (old_RV1_edit_mode != RV1_edit_mode) {\n      digitalWrite(GRN_LED_PIN, RV1_edit_mode != 1);\n      digitalWrite(RED_LED_PIN, RV1_edit_mode != 2);\n  }</code></pre></div>\n<p>Then we read the pots. For RV1, we update the settings based on what mode we‚Äôre in. For RV2, we map the read value between our min/max interval speed:</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">  // if RV1 changes, look at the edit mode\n  // to determine which setting should be updated\n  if (RV1_READ != RV1_STATE) {\n    RV1_STATE = RV1_READ;\n    if (RV1_edit_mode == 0) {\n      offset = RV1_STATE;\n    } else if (RV1_edit_mode == 1) {\n      depth = RV1_STATE;\n    } else if (RV1_edit_mode == 2) {\n      cc = RV1_STATE;\n    }\n  }\n\n  // use RV2 to update the speed of the interval\n  if (RV2_READ != RV2_STATE) {\n    RV2_STATE = RV2_READ;\n    // we map pot reads from 0-1023 to 0-127 for MIDI\n    // but now we&#39;re mapping 0-127 to MIN/MAX_SPEED\n    speed = map(RV2_STATE, 0, 127, MIN_SPEED, MAX_SPEED);\n  }</code></pre></div>\n<p>Finally we continuously check to see if the current timestamp minus the timestamp for the last message is larger than our interval; if so, send a new message:</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">  // 1. check the current time\n  // 2. compare it to the last time we sent a message\n  // 3. if we&#39;re past our interval, send a new message\n  unsigned long now = millis();\n  if (now - last_cc_sent &gt; speed) {\n    last_cc_sent = now;\n    // max is offset + depth, as long as it&#39;s between 0 and 127\n    int max_val = constrain(offset + depth, 0, 127);\n    int rand_val = random(offset, max_val);\n    // sendControlChange(CC, value, channel)\n    MIDI.sendControlChange(cc, rand_val, MIDI_CH);\n  }</code></pre></div>\n<h2>Adding MIDI in</h2>\n<p>Addind MIDI in isn‚Äôt too much work either, it‚Äôs just that the MIDI specification require the use of an optocoupler to electrically isolate the receiving circuit from the sending circuit. Looking at the Sparkfun schematic, the important pieces are:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/tech-blog/static/fa64f6b8ca55a94a9d5085d5870fc2b3/ec09f/midi-in-schematic.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.83783783783784%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACdElEQVQ4y52UW2/TQBCF8///BY9IvEBvqqCCXoKoUNOkLSGRkjqp716vd+31rp205TDehCQtCEgfRmvt2p/PzJydljESRSlQagm9EcYU8DlDmmfggj05W7+T29jca9VVAZeFyHKOulaoCFRVCqUMcTe9ROD0wGIH2p6tPzYUjQi1fF4BMxUjHn4D9x3E2RRhOgUvOfjkHI96H9J5h7vbPp1PwESyVCTsKvMUPIuf/Ki1eoEUsMkA49E1OO2x/gmy4Ssk3deQkQdvdINp4tpSaKNoLVEqgVwyGMpoDdQ5MpZgNjfgRUQRIqcDEfZQiwMkV28QhyNkhoGrCCpPUMTfkTodBMNzsGkHpkjoJ8UCyMdDxP0rCNexwJLUNjXURQqVeSiEDx67mNGe0CmEP8T97Ah6fgRWvqcy7UIlA1JZ2kxbyeAGivnwrroQBNFmWeCmgwRRlEHAI1t4WWXwe21Moj3o+2P8wBk8vg9+11uUgNzSylkA5t7aD8xS9p/s0az1TMO/OIOb7OERp3igiLID8GnXAq3CgMcYRS7cNIQqxW++2oyKgB4BI1IFtC00oTo39VwBNxX8K6qagF9Pl8AzG1IdIhp8IetsAPUzc/5NYZNyQmkugG2I/ABe5yM18hlQ/ycw6LTJ/AuF5uEE03gHfvfYAm1TtgLWJaV8AifcscByfkzXdhdsfLG2zbbAeHiJSB4S8DPk/BPGpDC6IbVGbQ9sfFnQXb9XH+D5O+hP3kKShWTQp8FiXgAkN5SKQ4sAk0Ebzm0HYTyhxjRjLkWusu2AqxlIStPER0kXIZacvMgQ0tSRxQuAvyIiQNPVZnTZqBa37Cf/r063Hh6N2AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Schematic of MIDI in circuit\"\n        title=\"Schematic of MIDI in circuit\"\n        src=\"/tech-blog/static/fa64f6b8ca55a94a9d5085d5870fc2b3/fcda8/midi-in-schematic.png\"\n        srcset=\"/tech-blog/static/fa64f6b8ca55a94a9d5085d5870fc2b3/12f09/midi-in-schematic.png 148w,\n/tech-blog/static/fa64f6b8ca55a94a9d5085d5870fc2b3/e4a3f/midi-in-schematic.png 295w,\n/tech-blog/static/fa64f6b8ca55a94a9d5085d5870fc2b3/fcda8/midi-in-schematic.png 590w,\n/tech-blog/static/fa64f6b8ca55a94a9d5085d5870fc2b3/efc66/midi-in-schematic.png 885w,\n/tech-blog/static/fa64f6b8ca55a94a9d5085d5870fc2b3/c83ae/midi-in-schematic.png 1180w,\n/tech-blog/static/fa64f6b8ca55a94a9d5085d5870fc2b3/ec09f/midi-in-schematic.png 1916w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>R5 is limiting current</li>\n<li>R6 is a pull-up resistor</li>\n<li>D3 is protection again reverse polarization</li>\n<li>The 6N138 is sending the data from two electrically disconnected circuits</li>\n</ul>\n<p>To have both hardware MIDI in and MIDI out, you‚Äôre looking at eight cheap and highly available components (not including the Arduino). No vactrols, no germanium transistors, no archaic ICs you have to source from estate sales.</p>\n<h2>Closing thoughts</h2>\n<p>The fun thing about this circuit is that you don‚Äôt have to control just one thing on one device:</p>\n<ul>\n<li>Traditional MIDI CC lets you control 127 parameters</li>\n<li>MIDI NRPN lets you control 16,383 parameters</li>\n<li>Thanks to MIDI channels, you can simultaneously control up to 16 devices</li>\n</ul>\n<p>We‚Äôre not just limited to parameter changes either, with MIDI you can:</p>\n<ul>\n<li>Control the clock that devices use</li>\n<li>Send program changes to jump between patches on the fly</li>\n<li>Send traditional notes but also microtonal notes now thanks to MIDI MPE</li>\n</ul>\n<p>If you‚Äôre interested in open-source MIDI projects, be sure to check out:</p>\n<ul>\n<li>Norns (<a href=\"https://monome.org/docs/norns/\">https://monome.org/docs/norns/</a>)</li>\n<li>Gizmo (<a href=\"https://cs.gmu.edu/~sean/projects/gizmo/\">https://cs.gmu.edu/~sean/projects/gizmo/</a>)</li>\n<li>MIDI Goblin (<a href=\"https://www.midigoblin.com/\">https://www.midigoblin.com/</a>)</li>\n<li>Midipal (<a href=\"https://github.com/pichenettes/midipal\">https://github.com/pichenettes/midipal</a>)</li>\n</ul>\n<p>Finally, I‚Äôm working on an open-source generative sequencer called Grandbot (<a href=\"https://github.com/handeyeco/Grandbot\">https://github.com/handeyeco/Grandbot</a>).</p>","frontmatter":{"title":"Fun with MIDI","date":"February 27, 2025","description":"Playing with MIDI circuits and code for beginners."}}},"pageContext":{"slug":"/fun-with-midi/","previous":{"fields":{"slug":"/nano-midipal/"},"frontmatter":{"title":"Midipal on the Arduino Nano"}},"next":null}},"staticQueryHashes":["63159454"]}